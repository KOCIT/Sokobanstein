#include <Arduboy2.h>
#include <ArduboyTones.h>
#include <math.h>

// ------------------------------------------------------
// Базовые объекты
// ------------------------------------------------------
Arduboy2 arduboy;

bool audioEnabled() {
  return arduboy.audio.enabled();
}

ArduboyTones sound(audioEnabled);

// ------------------------------------------------------
// Экран и рендер
// ------------------------------------------------------
constexpr float SCREEN_W_FL = 128.0f; 
constexpr float SCREEN_H_FL = 64.0f;
constexpr int SCREEN_W_INT  = 128;
constexpr int SCREEN_H_INT  = 64;

constexpr int   FPS_TARGET     = 60;
constexpr float FOV            = 2.0f;
constexpr float RAY_STEP       = 0.1f;
constexpr float MAX_DISTANCE   = 32.0f;
constexpr float MOVE_SPEED     = 0.15f;
constexpr float ROT_SPEED      = 0.12f;

constexpr int   SCREEN_CENTER_Y_INT = 32;
constexpr float INVERSE_SCREEN_W_FL = 1.0f / 128.0f;
constexpr float FOV_HALF            = 1.0f;

// ------------------------------------------------------
// Enum для объектов
// ------------------------------------------------------
enum TileType {
  TILE_EMPTY = 0,  // пусто
  TILE_WALL = 1,   // стена
  TILE_BOX = 2,    // кубический ящик
  TILE_GOAL = 3    // квадрат на полу
};

// --- TEXT ---
const char titleTop[] = "MOTHERHACKERS";
const char titleBottom[] = "Sokobanstein";
int indexTop = 0;
int indexBottom = 0;
unsigned long lastCharTime = 0;
const unsigned long charDelay = 120;

// ------------------------------------------------------
// Сложность игры
// ------------------------------------------------------
enum Difficulty {
  DIFF_EASY,    // легкая - карта с возможностью перемещения
  DIFF_MEDIUM,  // средняя - карта только для просмотра
  DIFF_HARD     // сложная - карта отключена
};

Difficulty gameDifficulty = DIFF_EASY;

// ------------------------------------------------------
// Карты уровней
// ------------------------------------------------------
#define MAP_W 8
#define MAP_H 8
#define NUM_LEVELS 4

// '0' - пусто, '1' - стена, '2' - ящик, '3' - цель
const char levelMaps[NUM_LEVELS][MAP_H][MAP_W + 1] PROGMEM = {
  // Уровень 0: 1 ящик, 1 цель, стена по середине
  {
    "11111111",
    "10000001",
    "10000001",
    "10011001",  // стена
    "10203001",  // ящик(2) и цель(3)
    "10000001",
    "10000001",
    "11111111"
  },
  // Уровень 1: 2 ящика, 2 цели
  {
    "11111111",
    "10000001",
    "10020001",
    "10003001",
    "10000001",
    "10023001",
    "10000001",
    "11111111"
  },
  // Уровень 2: 3 ящика, 3 цели
  {
    "11111111",
    "10000001",
    "10023001",
    "10000001",
    "10023001",
    "10023001",
    "10000001",
    "11111111"
  },
  // Уровень 3: 4 ящика, 4 цели
  {
    "11111111",
    "10023001",
    "10023001",
    "10000001",
    "10023001",
    "10000001",
    "10023001",
    "11111111"
  }
};


// Минималистичная капибара (128×64 пикселя) — идеально влезает
const unsigned char capybara[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x01, 0x58, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x04, 0x3c, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xe0, 0x03, 0xe0, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x60, 0x00, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1c, 0x04, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x08, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x14, 0x1f, 0x83, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x12, 0x10, 0xfc, 0x30, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x32, 0x10, 0x10, 0x78, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x10, 0x60, 0x70, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x24, 0x31, 0x80, 0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x28, 0x33, 0xcf, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf0, 0x31, 0xfd, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xdf, 0xe0, 0x00, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Минималистичная саламандра (128×64 пикселя) — идеально влезает
const unsigned char salamander[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x80, 0x0f, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcd, 0xc0, 0x1f, 0x87, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x80, 0x3f, 0x33, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x70, 0x71, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x40, 0x7b, 0xf8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xc0, 0x03, 0x3b, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xc0, 0x0f, 0x8f, 0xc8, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x01, 0x3f, 0xff, 0x30, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x01, 0x3f, 0xf8, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x7f, 0x3f, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x3f, 0x02, 0xff, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0xf8, 0x1f, 0x84, 0xff, 0xfc, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1e, 0x07, 0x07, 0xcd, 0xff, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x1f, 0xc1, 0xc3, 0xf9, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xde, 0x1f, 0x8e, 0x3b, 0xf3, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xcf, 0xfe, 0x1f, 0x0f, 0x8f, 0xcf, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0x8f, 0xfc, 0x3e, 0x0f, 0xc0, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9f, 0x0f, 0xfc, 0x7e, 0x0f, 0x8f, 0xcf, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x1f, 0x1f, 0xfc, 0xfe, 0x1f, 0x87, 0x87, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0xff, 0xfe, 0x1f, 0x07, 0x87, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0x1f, 0xff, 0xff, 0xfe, 0x7f, 0x0f, 0x8f, 0xb0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xdf, 0xff, 0xff, 0x0f, 0xcf, 0x70, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x03, 0xe7, 0xff, 0xff, 0x1f, 0xde, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x0f, 0x00, 0x00, 0xf1, 0xff, 0xff, 0x3f, 0xf9, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x9c, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xf3, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x7e, 0x7f, 0xff, 0xff, 0xef, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xe0, 0x00, 0x00, 0x3f, 0x7f, 0xff, 0xff, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x9f, 0xff, 0xff, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x07, 0x83, 0xff, 0xff, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x07, 0x80, 0x7f, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x07, 0x80, 0x03, 0xe0, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x0c, 0x3e, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0e, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x00, 0x00, 0x1e, 0x18, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0x38, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x1c, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x09, 0xb0, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1e, 0x00, 0x00, 0x01, 0x30, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x01, 0xcc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Минималистичная альпака-лицо (128×64 пикселя) — идеально влезает
const unsigned char alpaca_face[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x40, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x02, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x60, 0x00, 0x00, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa0, 0x00, 0x00, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x90, 0x00, 0x00, 0x09, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x48, 0x1f, 0xf0, 0x12, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x45, 0xe8, 0x5f, 0xa6, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x27, 0x00, 0x10, 0xe4, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x2c, 0x00, 0x00, 0x3c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0x00, 0x00, 0x18, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0e, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x90, 0x19, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x60, 0x0e, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x20, 0x06, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xcc, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x83, 0xc1, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x81, 0x81, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x81, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x45, 0xa2, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x43, 0xc6, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x18, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x07, 0xe0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Минималистичная медоед (128×64 пикселя) — идеально влезает
const unsigned char honey_badger[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xc0, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xc3, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x7f, 0xff, 0xc7, 0xfe, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xff, 0xc7, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xff, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xc7, 0xff, 0xf8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0xff, 0xff, 0xe3, 0xff, 0xfe, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0xf3, 0xff, 0xf3, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x00, 0x7e, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xff, 0xf0, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xfc, 0x3e, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x03, 0xce, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0x01, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0x80, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x07, 0xff, 0xfe, 0x01, 0xe1, 0xfc, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xf8, 0xff, 0xff, 0x01, 0x00, 0xbe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0xff, 0xff, 0x3f, 0xff, 0x83, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0xff, 0xff, 0xcf, 0xff, 0xc3, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xff, 0xff, 0xe7, 0xf1, 0xc2, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0x80, 0x0f, 0xfb, 0xe0, 0xe0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x78, 0x00, 0x00, 0xfd, 0xe0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x3e, 0xc0, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0x40, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// Минималистичное лого школы (128×64 пикселя) — идеально влезает
const unsigned char school_logo[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xf8, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xf8, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xf8, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xf8, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xff, 0xf8, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x07, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xf8, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x07, 0xff, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Минималистичная саламандер (128×64 пикселя) — идеально влезает
const unsigned char salamander_mini[] PROGMEM = {
  97, 52,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0c, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x03, 
	0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x07, 0xb7, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x37, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0d, 0x01, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 
	0xfc, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x07, 0xfb, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xdc, 0x1e, 0x0f, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0c, 0x01, 0x87, 0x2f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7c, 0x67, 0xdf, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x78, 0xcf, 0xbf, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3c, 0xfe, 0x71, 0xe7, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3c, 
	0xfe, 0xf1, 0xe7, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3c, 0xff, 0xf3, 0xc7, 0x3e, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xcf, 0x7c, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x80, 0x3b, 0xff, 0xdf, 0xec, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 
	0x1c, 0xff, 0xff, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x0e, 0xff, 0xff, 0xb0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x07, 0x3f, 0xff, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xe0, 0x00, 0x03, 0x0f, 0xfe, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
	0x07, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x00, 0x78, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 
	0xa8, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x28, 0x00, 0x00, 0x1f, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char honey_badger_mini[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xcf, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xdf, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 
	0xcf, 0xf9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xf2, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0xff, 0xf8, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x0f, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0xfc, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xef, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xf8, 0x00, 
	0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x31, 0xfe, 0x00, 0x3e, 0x04, 0x00, 0x00, 0x00, 0x00, 0x07, 
	0xcf, 0xf8, 0x41, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfb, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x7f, 0xfe, 0xe6, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x42, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char alpaca_face_mini[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x03, 
	0x40, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x00, 
	0x0d, 0x00, 0x00, 0x00, 0x02, 0xe0, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x02, 0x50, 0x00, 0x39, 0x00, 
	0x00, 0x00, 0x02, 0x57, 0xff, 0xab, 0x00, 0x00, 0x00, 0x01, 0x28, 0x04, 0x52, 0x00, 0x00, 0x00, 
	0x01, 0x30, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x80, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 
	0x00, 0x01, 0x80, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x80, 0x78, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0xfc, 0x84, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x41, 0x02, 
	0x08, 0x00, 0x00, 0x00, 0x00, 0x42, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x42, 0xcd, 0x08, 0x00, 
	0x00, 0x00, 0x00, 0x42, 0x31, 0x08, 0x00, 0x00, 0x00, 0x00, 0x42, 0x31, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x42, 0x21, 0x08, 0x00, 0x00, 0x00, 0x00, 0x43, 0x7b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x41, 
	0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfc, 0x18, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char capybara_mini[] PROGMEM = {
  128, 64,  // ширина, высота — обязательно первые два байта!

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xa0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x30, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0xb0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x04, 0x38, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x07, 0xc0, 0x70, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 
	0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 
	0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x01, 0x60, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x18, 0x20, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x98, 0x7f, 0xa0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x94, 0x9e, 0x30, 0x80, 0x00, 
	0x00, 0x00, 0x01, 0x14, 0x8c, 0x31, 0x00, 0x00, 0x00, 0x00, 0x03, 0x18, 0x98, 0x61, 0x00, 0x00, 
	0x00, 0x00, 0x07, 0x38, 0x9f, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 0x7c, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


char currentMap[MAP_H][MAP_W + 1];

// ------------------------------------------------------
// Игрок - ИСПРАВЛЕНА НАЧАЛЬНАЯ ПОЗИЦИЯ
// ------------------------------------------------------
// Начальная позиция должна быть в свободной клетке
// Проверяем карту: строка 1, колонка 1 = '0' (пусто)
constexpr float PLAYER_START_X = 1.5f;  // Изменено с 3.5 на 1.5
constexpr float PLAYER_START_Y = 1.5f;  // Изменено с 3.5 на 1.5

float playerOnX   = PLAYER_START_X;
float playerOnY   = PLAYER_START_Y;
float playerAngle = 0.0f;

// ------------------------------------------------------
// Игровые состояния
// ------------------------------------------------------
enum GameState {
  STATE_SHOW_LOGO,
  STATE_TUTORIAL_1,  // Слайд 1 обучения
  STATE_TUTORIAL_2,  // Слайд 2 обучения  
  STATE_TUTORIAL_3,  // Слайд 3 обучения
  STATE_TUTORIAL_4,  // Слайд 3 обучения
  STATE_MENU,
  STATE_PLAYING,
  STATE_MAP_VIEW,
  // STATE_BOX_CONFIRM,
  STATE_LEVEL_COMPLETE,
  STATE_SHOW_TRIBE,
  STATE_GAME_COMPLETE,
  STATE_EXIT
};

GameState gameState = STATE_SHOW_LOGO;
int       currentLevel = 0;
bool      menuMusicPlaying = false;

// Координаты последнего перемещенного ящика (для отмены)
// int lastBoxX = -1;
// int lastBoxY = -1;
// int lastBoxPrevX = -1;
// int lastBoxPrevY = -1;

// Переменные времени для управления движением
unsigned long lastMoveTime = 0;
unsigned long lastMapMoveTime = 0;

// ------------------------------------------------------
// Музыка
// ------------------------------------------------------
const uint16_t menuMusic[] PROGMEM = {
  // Часть 1
  440, 500,  // A4
  440, 500,  // A4  
  440, 500,  // A4
  349, 350,  // F4
  523, 150,  // C5
  440, 500,  // A4
  349, 350,  // F4
  523, 150,  // C5
  440, 700,  // A4 (длинная)

  // Часть 2
  659, 500,  // E5
  659, 500,  // E5
  659, 500,  // E5
  698, 350,  // F#5
  523, 150,  // C5
  415, 500,  // A#4
  349, 350,  // F4
  523, 150,  // C5
  440, 700,  // A4 (длинная)


  // Часть 3
  880, 500,  // A5
  440, 350,  // A4
  440, 150,  // A4 (короткая)
  880, 500,  // A5
  830, 350,  // G#5
  784, 150,  // G5
  740, 150,  // F#5
  698, 150,  // F#5
  740, 400,  // F#5 (чуть длиннее)

  // Часть 4
  466, 200,  // B4
  622, 300,  // D#5
  587, 150,  // D5
  554, 150,  // C#5
  523, 150,  // C5
  494, 150,  // B4
  523, 400,  // C5 (завершающая)
  TONES_END
};

// ------------------------------------------------------
// Звуки
// ------------------------------------------------------
void playStepSound() {
  sound.tone(200, 30);
}

void playBoxPushSound() {
  sound.tone(400, 50);
}

void playLevelCompleteSound() {
  sound.tone(600, 100);
  delay(50);
  sound.tone(700, 100);
  delay(50);
  sound.tone(800, 150);
}

// ------------------------------------------------------
// Работа с картой
// ------------------------------------------------------
bool isInsideMap(int x, int y) {
  return (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H);
}

char getTile(int x, int y) {
  if (!isInsideMap(x, y)) return '1';
  return currentMap[y][x];
}

void setTile(int x, int y, char t) {
  if (!isInsideMap(x, y)) return;
  currentMap[y][x] = t;
}

bool isBlockingTile(char t) {
  return (t == '1' || t == '2');
}

bool checkLevelComplete() {
  for (int y = 0; y < MAP_H; ++y) {
    for (int x = 0; x < MAP_W; ++x) {
      char t = getTile(x, y);
      if (t == '3') return false; // есть пустая цель
    }
  }
  return true; // все цели заняты ящиками
}

void loadLevel(int lvl) {
  for (int y = 0; y < MAP_H; ++y) {
    for (int x = 0; x < MAP_W; ++x) {
      char c = (char)pgm_read_byte(&(levelMaps[lvl][y][x]));
      currentMap[y][x] = c;
    }
    currentMap[y][MAP_W] = '\0';
  }

  // Устанавливаем начальную позицию в зависимости от уровня
  // Для каждого уровня находим первую свободную клетку
  bool foundStart = false;
  for (int y = 1; y < MAP_H - 1 && !foundStart; ++y) {
    for (int x = 1; x < MAP_W - 1 && !foundStart; ++x) {
      if (getTile(x, y) == '0') {
        playerOnX = (float)x + 0.5f;
        playerOnY = (float)y + 0.5f;
        foundStart = true;
      }
    }
  }
  
  // Если не нашли свободную клетку, используем дефолтную
  if (!foundStart) {
    playerOnX = 1.5f;
    playerOnY = 1.5f;
  }
  
  playerAngle = 0.0f;
  // lastBoxX = -1;
  // lastBoxY = -1;
  
  // Инициализируем время движения при загрузке уровня
  lastMoveTime = millis();
  lastMapMoveTime = millis();
}

void goToNextLevel() {
  if (currentLevel < NUM_LEVELS - 1) {
    currentLevel++;
    loadLevel(currentLevel);
    gameState = STATE_PLAYING;
  } else {
    gameState = STATE_GAME_COMPLETE;
    playLevelCompleteSound();
  }
}

// ------------------------------------------------------
// Рендер кубического ящика
// ------------------------------------------------------
void drawBoxSlice(int x, float distance) {
  if (distance < 0.1f) distance = 0.1f;
  int lineHeight = (int)(64.0f / distance);
  int boxHeight = (lineHeight * 2) / 3;
  if (boxHeight < 8) boxHeight = 8;
  if (boxHeight > 50) boxHeight = 50;
  
  int drawStart = 32 - boxHeight / 2;
  int drawEnd = 32 + boxHeight / 2;

  if (drawStart < 0) drawStart = 0;
  if (drawEnd >= 64) drawEnd = 63;

  for (int y = drawStart; y <= drawEnd; ++y) {
    arduboy.drawPixel(x, y, WHITE);
  }
  
  for (int y = drawStart + 2; y < drawEnd - 1; y += 3) {
    if (x % 4 == 0 && y < drawEnd - 2) {
      arduboy.drawPixel(x, y, BLACK);
      arduboy.drawPixel(x, y + 1, BLACK);
    }
  }
}

// ------------------------------------------------------
// Рендер квадрата на полу
// ------------------------------------------------------
void drawGoalSlice(int x, float distance) {
  if (distance < 0.1f) distance = 0.1f;
  int thickness = 4;
  int drawStart = 58;
  int drawEnd = 62;
  
  if (drawStart < 0) drawStart = 0;
  if (drawEnd >= 64) drawEnd = 63;

  for (int y = drawStart; y <= drawEnd; ++y) {
    if ((x + y) % 2 == 0) {
      arduboy.drawPixel(x, y, WHITE);
    }
  }
}

// ------------------------------------------------------
// Рендер стены
// ------------------------------------------------------
void drawWallSlice(int x, float distance) {
  if (distance < 0.1f) distance = 0.1f;
  int lineHeight = (int)(64.0f / distance);
  int drawStart = 32 - lineHeight / 2;
  int drawEnd   = 32 + lineHeight / 2;

  if (drawStart < 0) drawStart = 0;
  if (drawEnd >= 64) drawEnd = 63;

  for (int y = drawStart; y <= drawEnd; ++y) {
    bool on = ((((y / 2) + (x / 4)) % 2 == 0) || (y == drawStart) || (y == drawEnd));
    if (on) arduboy.drawPixel(x, y, WHITE);
  }
}

// ------------------------------------------------------
// Каст луча - ИСПРАВЛЕННАЯ ВЕРСИЯ С ПРОЗРАЧНЫМИ ЦЕЛЯМИ
// ------------------------------------------------------
void castRayAndDraw(int screenX) {
  float rayAngle = playerAngle - FOV_HALF + ((float)screenX * INVERSE_SCREEN_W_FL) * FOV;
  float rayDirX = cos(rayAngle);
  float rayDirY = sin(rayAngle);

  float distance = 0.0f;
  bool hitWall = false;
  bool hitBox = false;
  bool foundGoal = false;
  char hitTile = '1';
  float boxDistance = MAX_DISTANCE;
  float goalDistance = MAX_DISTANCE;
  
  // Переменные для хранения позиции цели
  int goalX = -1, goalY = -1;

  // Сначала ищем цель на полу
  while (distance < MAX_DISTANCE) {
    distance += RAY_STEP;
    int mapX = (int)(playerOnX + rayDirX * distance);
    int mapY = (int)(playerOnY + rayDirY * distance);

    if (!isInsideMap(mapX, mapY)) {
      break;
    }

    char t = getTile(mapX, mapY);
    
    // Нашли цель - запоминаем расстояние и позицию
    if (t == '3' && goalDistance > MAX_DISTANCE) {
      goalDistance = distance;
      foundGoal = true;
      goalX = mapX;
      goalY = mapY;
      break;
    }
    
    // Если нашли стену или ящик - прерываем поиск цели
    if (t == '1' || t == '2') {
      break;
    }
  }

  // Теперь трассируем луч для стен и ящиков
  distance = 0.0f;
  hitWall = false;
  hitBox = false;
  
  while ((!hitWall && !hitBox) && distance < MAX_DISTANCE) {
    distance += RAY_STEP;
    int mapX = (int)(playerOnX + rayDirX * distance);
    int mapY = (int)(playerOnY + rayDirY * distance);

    if (!isInsideMap(mapX, mapY)) {
      hitWall = true;
      break;
    }

    char t = getTile(mapX, mapY);
    
    // Нашли ящик
    if (t == '2' && !hitBox) {
      hitBox = true;
      boxDistance = distance;
      hitTile = '2';
    }
    
    // Нашли стену
    if (t == '1' && !hitWall) {
      hitWall = true;
      hitTile = '1';
    }
  }

  // Рендерим пол с текстурами целей - УПРОЩЕННАЯ ВЕРСИЯ
  for (int y = 40; y < 64; y += 2) { // Редкие пиксели, шаг 2
    // Быстрое вычисление без точных мировых координат
    float approxDistance = 32.0f / (y - 30); // Приблизительное расстояние
    
    // Приблизительные координаты на карте
    int mapX = (int)(playerOnX + rayDirX * approxDistance);
    int mapY = (int)(playerOnY + rayDirY * approxDistance);
    
    // Быстрая проверка цели
    if (isInsideMap(mapX, mapY) && getTile(mapX, mapY) == '3') {
      // Простой мигающий эффект
      if ((millis() / 300 + screenX + y) % 4 < 2) {
        arduboy.drawPixel(screenX, y, WHITE);
      }
    }
  }

  // Рендерим цель на стене (если видна)
  if (foundGoal && goalDistance < MAX_DISTANCE) {
    // Проверяем, не закрыта ли цель стеной или ящиком
    if ((!hitWall || goalDistance < distance) && (!hitBox || goalDistance < boxDistance)) {
      drawGoalSlice(screenX, goalDistance);
    }
  }

  // Рендерим ящик или стену
  if (hitBox || hitWall) {
    float renderDist = hitBox ? boxDistance : distance;
    if (hitBox) {
      drawBoxSlice(screenX, renderDist);
    } else {
      drawWallSlice(screenX, renderDist);
    }
  }
}

// ------------------------------------------------------
// Определение направления движения
// ------------------------------------------------------
void getDirection(int& dx, int& dy, float angle) {
  // Нормализуем угол в диапазон [0, 2*PI)
  while (angle < 0) angle += 2.0f * 3.14159265f;
  while (angle >= 2.0f * 3.14159265f) angle -= 2.0f * 3.14159265f;
  
  // Используем cos и sin для определения направления
  float cosVal = cos(angle);
  float sinVal = sin(angle);
  
  // Определяем основное направление по наибольшей компоненте
  if (fabs(cosVal) > fabs(sinVal)) {
    // Горизонтальное движение (восток или запад)
    dx = (cosVal > 0) ? 1 : -1;
    dy = 0;
  } else {
    // Вертикальное движение (север или юг)
    dx = 0;
    dy = (sinVal > 0) ? 1 : -1; // sin > 0 = юг (вниз), sin < 0 = север (вверх)
  }
}

// ------------------------------------------------------
// Проверка столкновений - ИСПРАВЛЕНА
// ------------------------------------------------------
bool canMoveTo(float newX, float newY) {
  // Проверяем текущую позицию игрока
  int currentX = (int)playerOnX;
  int currentY = (int)playerOnY;
  
  // Проверяем, что текущая позиция свободна (на случай если игрок застрял)
  if (isInsideMap(currentX, currentY)) {
    char currentTile = getTile(currentX, currentY);
    if (isBlockingTile(currentTile)) {
      // Игрок застрял в стене/ящике - не можем двигаться
      return false;
    }
  }
  
  // Проверяем целевую позицию
  int targetX = (int)newX;
  int targetY = (int)newY;
  
  if (!isInsideMap(targetX, targetY)) {
    return false;
  }
  
  char tile = getTile(targetX, targetY);
  if (isBlockingTile(tile)) {
    return false;
  }
  
  // Если игрок переходит в другую клетку, проверяем промежуточные
  if (targetX != currentX || targetY != currentY) {
    float dx = newX - playerOnX;
    float dy = newY - playerOnY;
    float steps = fabs(dx) > fabs(dy) ? fabs(dx) : fabs(dy);
    if (steps > 0.1f) {
      float stepX = dx / steps;
      float stepY = dy / steps;
      for (int i = 1; i <= (int)steps; ++i) {
        int checkX = (int)(playerOnX + stepX * i);
        int checkY = (int)(playerOnY + stepY * i);
        if (isInsideMap(checkX, checkY)) {
          char checkTile = getTile(checkX, checkY);
          if (isBlockingTile(checkTile)) {
            return false;
          }
        }
      }
    }
  }
  
  return true;
}

// Проверка возможности сдвинуть ящик
bool canPushBox(int boxX, int boxY, float angle) {
  int dx, dy;
  getDirection(dx, dy, angle);
  
  int nextX = boxX + dx;
  int nextY = boxY + dy;
  
  if (!isInsideMap(nextX, nextY)) {
    return false;
  }
  
  char nextTile = getTile(nextX, nextY);
  return (nextTile == '0' || nextTile == '3');
}

// Сдвиг ящика
bool pushBox(int boxX, int boxY, float angle) {
  if (!canPushBox(boxX, boxY, angle)) {
    return false;
  }
  
  int dx, dy;
  getDirection(dx, dy, angle);
  
  int nextX = boxX + dx;
  int nextY = boxY + dy;
  
  char nextTile = getTile(nextX, nextY);
  
  // Сохраняем для возможной отмены
  // lastBoxPrevX = boxX;
  // lastBoxPrevY = boxY;
  // lastBoxX = nextX;
  // lastBoxY = nextY;
  
  // Сдвигаем ящик
  setTile(boxX, boxY, '0');
  setTile(nextX, nextY, '2');
  
  playBoxPushSound();
  
  // Проверяем, попал ли ящик на цель
  // if (nextTile == '3') {
  //   gameState = STATE_BOX_CONFIRM;
  //   return true;
  // }
  
  // Проверяем завершение уровня
  if (checkLevelComplete()) {
    gameState = STATE_SHOW_TRIBE;
    playLevelCompleteSound();
    return true;
  }
  
  return true;
}

// ------------------------------------------------------
// Управление - ИСПРАВЛЕНО
// ------------------------------------------------------
void handleMovement() {
  unsigned long currentTime = millis();
  
  // Инициализация при первом вызове
  if (lastMoveTime == 0) {
    lastMoveTime = currentTime;
  }
  
  if (currentTime - lastMoveTime < 150) return;
  
  float moveX = cos(playerAngle) * MOVE_SPEED;
  float moveY = sin(playerAngle) * MOVE_SPEED;
  
  // Вперёд (обычное движение)
  if (arduboy.pressed(UP_BUTTON) && !arduboy.pressed(A_BUTTON)) {
    float newX = playerOnX + moveX;
    float newY = playerOnY + moveY;
    
    if (canMoveTo(newX, newY)) {
      playerOnX = newX;
      playerOnY = newY;
      playStepSound();
      lastMoveTime = currentTime;
    }
  }

  // Сдвиг ящика (UP + A)
  if (arduboy.pressed(UP_BUTTON) && arduboy.pressed(A_BUTTON)) {
      int dx, dy;
      getDirection(dx, dy, playerAngle);

      int boxX = (int)playerOnX + dx;
      int boxY = (int)playerOnY + dy;

      // Перед нами ящик?
      if (isInsideMap(boxX, boxY) && getTile(boxX, boxY) == '2') {

          if (pushBox(boxX, boxY, playerAngle)) {

              // Теперь двигаем игрока в сторону dx,dy
              float newX = playerOnX + dx;
              float newY = playerOnY + dy;

              playerOnX = newX;
              playerOnY = newY;

              lastMoveTime = currentTime;
              return;
          }
      }
}


  // Назад
  if (arduboy.pressed(DOWN_BUTTON)) {
    float newX = playerOnX - moveX;
    float newY = playerOnY - moveY;
    
    if (canMoveTo(newX, newY)) {
      playerOnX = newX;
      playerOnY = newY;
      playStepSound();
      lastMoveTime = currentTime;
    }
  }

  // Повороты
  if (arduboy.pressed(LEFT_BUTTON)) {
    playerAngle -= ROT_SPEED;
    lastMoveTime = currentTime;
  }
  if (arduboy.pressed(RIGHT_BUTTON)) {
    playerAngle += ROT_SPEED;
    lastMoveTime = currentTime;
  }
}

// ------------------------------------------------------
// Управление на карте 2D
// ------------------------------------------------------
void handleMapMovement() {
  unsigned long currentTime = millis();
  
  // Инициализация при первом вызове
  if (lastMapMoveTime == 0) {
    lastMapMoveTime = currentTime;
  }
  
  if (currentTime - lastMapMoveTime < 300) return; // Увеличиваем задержку для 2D режима
  
  float moveSpeed = 0.3f;
  float moveX = cos(playerAngle) * moveSpeed;
  float moveY = sin(playerAngle) * moveSpeed;
  
  // Вперёд (обычное движение)
  if (arduboy.pressed(UP_BUTTON) && !arduboy.pressed(A_BUTTON)) {
    float newX = playerOnX + moveX;
    float newY = playerOnY + moveY;
    
    // Определяем направление для точной проверки
    int dx, dy;
    getDirection(dx, dy, playerAngle);
    
    // Вычисляем целевую клетку в направлении движения
    int currentCellX = (int)playerOnX;
    int currentCellY = (int)playerOnY;
    int targetCellX = currentCellX + dx;
    int targetCellY = currentCellY + dy;
    
    // Проверяем, можем ли мы войти в целевую клетку
    if (isInsideMap(targetCellX, targetCellY)) {
      char tile = getTile(targetCellX, targetCellY);
      
      // Если целевая клетка блокирующая - не двигаемся
      if (isBlockingTile(tile)) {
        // Не двигаемся
      } else {
        // Можем двигаться
        playerOnX = newX;
        playerOnY = newY;
        lastMapMoveTime = currentTime;
      }
    } else {
      // Выход за границы карты - не двигаемся
    }
  }

  // Сдвиг ящика (UP + A) на карте - ИСПРАВЛЕННАЯ ЛОГИКА
  if (arduboy.pressed(UP_BUTTON) && arduboy.pressed(A_BUTTON)) {
    float newX = playerOnX + moveX;
    float newY = playerOnY + moveY;
    
    // Определяем направление для точной проверки
    int dx, dy;
    getDirection(dx, dy, playerAngle);
    
    // Вычисляем целевую клетку в направлении движения
    int currentCellX = (int)playerOnX;
    int currentCellY = (int)playerOnY;
    int targetCellX = currentCellX + dx;
    int targetCellY = currentCellY + dy;
    
    if (isInsideMap(targetCellX, targetCellY)) {
      char tile = getTile(targetCellX, targetCellY);
      
      // Если перед нами ящик
      if (tile == '2') {
        // Пытаемся сдвинуть ящик
        if (pushBox(targetCellX, targetCellY, playerAngle)) {
          // Двигаем игрока в целевую клетку
          int nextPlayerCellX = targetCellX;
          int nextPlayerCellY = targetCellY;
          
          // Проверяем, что новая позиция игрока свободна
          if (isInsideMap(nextPlayerCellX, nextPlayerCellY) && !isBlockingTile(getTile(nextPlayerCellX, nextPlayerCellY))) {
            playerOnX = (float)nextPlayerCellX + 0.5f;
            playerOnY = (float)nextPlayerCellY + 0.5f;
          } else {
            // Если не можем войти, двигаемся ближе к ящику
            playerOnX = newX;
            playerOnY = newY;
          }
          lastMapMoveTime = currentTime;
          return;
        }
      } 
      // Если перед нами не ящик, проверяем обычное движение
      else if (!isBlockingTile(tile)) {
        playerOnX = newX;
        playerOnY = newY;
        lastMapMoveTime = currentTime;
      }
    }
  }

  // Повороты
  if (arduboy.pressed(LEFT_BUTTON)) {
    playerAngle -= ROT_SPEED * 2.0f;
    lastMapMoveTime = currentTime;
  }
  if (arduboy.pressed(RIGHT_BUTTON)) {
    playerAngle += ROT_SPEED * 2.0f;
    lastMapMoveTime = currentTime;
  }
}

// ------------------------------------------------------
// Полноэкранная карта
// ------------------------------------------------------
void drawFullScreenMap() {
  arduboy.clear();
  
  arduboy.setCursor(50, 0);
  arduboy.print(F("MAP"));
  
  const int scale = 6;
  int mapW = MAP_W * scale;
  int mapH = MAP_H * scale;
  int offsetX = (128 - mapW) / 2;
  int offsetY = 8;
  
  arduboy.drawRect(offsetX - 1, offsetY - 1, mapW + 2, mapH + 2, WHITE);
  
  for (int y = 0; y < MAP_H; ++y) {
    for (int x = 0; x < MAP_W; ++x) {
      char t = getTile(x, y);
      int sx = offsetX + x * scale;
      int sy = offsetY + y * scale;
      
      if (t == '1') {
        arduboy.fillRect(sx, sy, scale, scale, WHITE);
      } else if (t == '2') {
        arduboy.fillRect(sx, sy, scale, scale, WHITE);
        arduboy.drawRect(sx + 1, sy + 1, scale - 2, scale - 2, BLACK);
      } else if (t == '3') {
        arduboy.drawLine(sx, sy, sx + scale - 1, sy + scale - 1, WHITE);
        arduboy.drawLine(sx + scale - 1, sy, sx, sy + scale - 1, WHITE);
      }
    }
  }
  
  // Игрок
  int px = offsetX + (int)(playerOnX * scale);
  int py = offsetY + (int)(playerOnY * scale);
  
  arduboy.drawPixel(px, py, WHITE);
  arduboy.drawPixel(px + 1, py, WHITE);
  arduboy.drawPixel(px - 1, py, WHITE);
  arduboy.drawPixel(px, py + 1, WHITE);
  arduboy.drawPixel(px, py - 1, WHITE);
  
  int dx = (int)(cos(playerAngle) * 3.0f);
  int dy = (int)(sin(playerAngle) * 3.0f);
  arduboy.drawLine(px, py, px + dx, py + dy, WHITE);
  
  if (gameDifficulty == DIFF_EASY) {
    arduboy.setCursor(20, 56);
    arduboy.print(F("A=CLOSE MAP"));
  } else {
    arduboy.setCursor(15, 56);
    arduboy.print(F("A=CLOSE VIEW"));
  }
}

// ------------------------------------------------------
// Экраны
// ------------------------------------------------------
void drawMenuScreen() {
  arduboy.setCursor(20, 2);
  arduboy.print(F("BOX PUZZLE"));

  arduboy.setCursor(0, 12);
  arduboy.print(F("UP/DOWN: move"));
  arduboy.setCursor(0, 20);
  arduboy.print(F("LEFT/RIGHT: turn"));
  arduboy.setCursor(0, 28);
  arduboy.print(F("UP+A: push box"));
  
  arduboy.setCursor(0, 38);
  if (gameDifficulty == DIFF_EASY) {
    arduboy.print(F("> EASY"));
  } else {
    arduboy.print(F("  EASY"));
  }
  
  arduboy.setCursor(0, 46);
  if (gameDifficulty == DIFF_MEDIUM) {
    arduboy.print(F("> MEDIUM"));
  } else {
    arduboy.print(F("  MEDIUM"));
  }
  
  arduboy.setCursor(0, 54);
  if (gameDifficulty == DIFF_HARD) {
    arduboy.print(F("> HARD"));
  } else {
    arduboy.print(F("  HARD"));
  }

  arduboy.setCursor(0, 0);
  arduboy.print(F("A=START B=EXIT"));
}

// ------------------------------------------------------
// Функция полного сброса игры
// ------------------------------------------------------
void resetGame() {
  currentLevel = 0;
  playerOnX = PLAYER_START_X;
  playerOnY = PLAYER_START_Y;
  playerAngle = 0.0f;
  // lastBoxX = -1;
  // lastBoxY = -1;
  // lastBoxPrevX = -1;
  // lastBoxPrevY = -1;
  lastMoveTime = 0;
  lastMapMoveTime = 0;
  menuMusicPlaying = false;
}

// ------------------------------------------------------
// Обновленная функция updateMenu() с обработкой B
// ------------------------------------------------------
void updateMenu() {
  if (!menuMusicPlaying) {
    sound.noTone();
    sound.tones(menuMusic);
    menuMusicPlaying = true;
  }

  // Выбор сложности
  if (arduboy.justPressed(UP_BUTTON)) {
    if (gameDifficulty > DIFF_EASY) {
      gameDifficulty = (Difficulty)((int)gameDifficulty - 1);
    }
  }
  if (arduboy.justPressed(DOWN_BUTTON)) {
    if (gameDifficulty < DIFF_HARD) {
      gameDifficulty = (Difficulty)((int)gameDifficulty + 1);
    }
  }

  drawMenuScreen();

  if (arduboy.justPressed(A_BUTTON)) {
    sound.noTone();
    menuMusicPlaying = false;
    resetGame(); // Сбрасываем игру перед началом
    loadLevel(currentLevel);
    gameState = STATE_PLAYING;
  } else if (arduboy.justPressed(B_BUTTON)) {
    sound.noTone();
    menuMusicPlaying = false;
    gameState = STATE_EXIT;
  }
}

void updateGame() {
  // Кнопка B возвращает в меню с сбросом состояния
  if (arduboy.justPressed(B_BUTTON)) {
    sound.noTone();
    // Сбрасываем состояние игры
    currentLevel = 0;
    gameState = STATE_SHOW_LOGO;
    menuMusicPlaying = false;
    return;
  }
  
  if (arduboy.justPressed(A_BUTTON) && !arduboy.pressed(UP_BUTTON)) {
    if (gameDifficulty == DIFF_EASY || gameDifficulty == DIFF_MEDIUM) {
      if (gameState == STATE_PLAYING) {
        gameState = STATE_MAP_VIEW;
        return;
      } else if (gameState == STATE_MAP_VIEW) {
        gameState = STATE_PLAYING;
        return;
      }
    }
  }
  
  if (gameState == STATE_MAP_VIEW) {
    drawFullScreenMap();
    
    if (gameDifficulty == DIFF_EASY) {
      handleMapMovement();
    }
  } 
  else if (gameState == STATE_PLAYING) {
    handleMovement();
    
    for (int x = 0; x < 128; ++x) {
      castRayAndDraw(x);
    }
  }
}

// ------------------------------------------------------
// Обновленная функция updateBoxConfirm() с обработкой B
// ------------------------------------------------------
// void updateBoxConfirm() {
//   arduboy.clear();
//   arduboy.setCursor(10, 10);
//   arduboy.print(F("Box on goal!"));
//   arduboy.setCursor(5, 20);
//   arduboy.print(F("Keep it?"));
//   arduboy.setCursor(0, 30);
//   arduboy.print(F("B=YES DOWN=NO"));
  
//   if (arduboy.justPressed(B_BUTTON)) {
//     // Оставляем ящик на месте
//     gameState = STATE_PLAYING;
//     if (checkLevelComplete()) {
//       gameState = STATE_SHOW_TRIBE;
//       playLevelCompleteSound();
//     }
//   } else if (arduboy.justPressed(DOWN_BUTTON)) {
//     // Возвращаем ящик назад
//     if (lastBoxX >= 0 && lastBoxY >= 0 && lastBoxPrevX >= 0 && lastBoxPrevY >= 0) {
//       setTile(lastBoxX, lastBoxY, '3');
//       setTile(lastBoxPrevX, lastBoxPrevY, '2');
//       lastBoxX = -1;
//       lastBoxY = -1;
//     }
//     gameState = STATE_PLAYING;
//   }
// }

// ------------------------------------------------------
// Обновленная функция updateLevelComplete() с обработкой B
// ------------------------------------------------------
void updateLevelComplete() {
  arduboy.clear();
  if (currentLevel < NUM_LEVELS - 1) {
    arduboy.setCursor(15, 20);
    arduboy.print(F("LEVEL"));
    arduboy.setCursor(50, 20);
    arduboy.print(currentLevel + 1);
    arduboy.setCursor(20, 30);
    arduboy.print(F("COMPLETE!"));
    arduboy.setCursor(25, 45);
    arduboy.print(F("A=NEXT B=MENU")); // Добавили B=MENU
  } else {
    arduboy.setCursor(10, 15);
    arduboy.print(F("CONGRATS!"));
    arduboy.setCursor(5, 25);
    arduboy.print(F("GAME COMPLETE"));
    arduboy.setCursor(20, 40);
    arduboy.print(F("A=MENU B=EXIT"));
  }
  
  if (arduboy.justPressed(A_BUTTON)) {
    if (currentLevel < NUM_LEVELS - 1) {
      goToNextLevel();
    } else {
      resetGame(); // Сбрасываем игру при завершении
      gameState = STATE_MENU;
      menuMusicPlaying = false;
    }
  } else if (arduboy.justPressed(B_BUTTON)) {
    resetGame(); // Сбрасываем игру при выходе в меню
    gameState = STATE_MENU;
    menuMusicPlaying = false;
  }
}

// ------------------------------------------------------
// Обновленная функция updateShowTribe() с обработкой B
// ------------------------------------------------------
void updateShowTribe() {
  arduboy.clear();
  switch (currentLevel) {
    case 0:
      arduboy.drawSlowXYBitmap(-15, 0, capybara, 128, 64, WHITE);
      arduboy.setCursor(47, 56);
      arduboy.print(F("CAPYBARA"));
      arduboy.setCursor(10, 45);
      arduboy.print(F("A=NEXT B=MENU")); // Добавили B=MENU
      break;
    case 1:
      arduboy.drawSlowXYBitmap(-20, 0, salamander, 128, 64, WHITE);
      arduboy.setCursor(30, 56);
      arduboy.print(F("SALAMANDER"));
      arduboy.setCursor(10, 45);
      arduboy.print(F("A=NEXT B=MENU"));
      break;
    case 2:
      arduboy.drawSlowXYBitmap(-15, 0, alpaca_face, 128, 64, WHITE);
      arduboy.setCursor(47, 56);
      arduboy.print(F("ALPACA"));
      arduboy.setCursor(10, 45);
      arduboy.print(F("A=NEXT B=MENU"));
      break;
    case 3:
      arduboy.drawSlowXYBitmap(10, 0, honey_badger, 128, 64, WHITE);
      arduboy.setCursor(30, 56);
      arduboy.print(F("HONEY BADGER"));
      arduboy.setCursor(10, 45);
      arduboy.print(F("A=NEXT B=MENU"));
      break;
  }
  
  // Мигающая неоновая рамка
  if ((millis() / 400) % 2 == 0) {
    arduboy.drawRoundRect(0, 0, 128, 64, 8, WHITE);
  }
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_LEVEL_COMPLETE;
  } else if (arduboy.justPressed(B_BUTTON)) {
    resetGame(); // Сбрасываем игру
    gameState = STATE_MENU;
    menuMusicPlaying = false;
  }
}


void updateGameComplete() {
  arduboy.clear();
  arduboy.setCursor(5, 10);
  arduboy.print(F("CONGRATULATIONS!"));
  arduboy.setCursor(10, 20);
  arduboy.print(F("YOU COMPLETED"));
  arduboy.setCursor(15, 30);
  arduboy.print(F("THIS AMAZING"));
  arduboy.setCursor(20, 40);
  arduboy.print(F("GAME!"));
  arduboy.setCursor(25, 50);
  arduboy.print(F("A=MENU"));
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_MENU;
    menuMusicPlaying = false;
  }
}

void updateExitScreen() {
  arduboy.setCursor(30, 24);
  arduboy.print(F("GOOD BYE"));
  arduboy.setCursor(6, 36);
  arduboy.print(F("RESET TO PLAY AGAIN"));
}


void updateLogoShow() {
  arduboy.clear();
  arduboy.drawSlowXYBitmap(-10, 20, school_logo, 128, 64, WHITE);
  // Подпись
  // arduboy.setCursor(55, 22);
  // arduboy.print(F("Sokoban3D"));
  // arduboy.setCursor(55, 38);
  // arduboy.print(F("Press (A)"));

  // --- INTRO: Show text letter by letter ---
  unsigned long t = millis();
  if (t - lastCharTime > charDelay) {
    if (indexTop < strlen(titleTop)) indexTop++;
    else if (indexBottom < strlen(titleBottom)) indexBottom++;
    lastCharTime = t;
  }

  // DRAW TOP TITLE
  int xTop = (128 - indexTop * 6) / 2 + 20;
  for (int i = 0; i < indexTop; i++) {
    arduboy.setCursor(xTop + i * 6, 18);
    arduboy.print(titleTop[i]);
  }

  // DRAW BOTTOM TITLE
  int xBot = (128 - indexBottom * 6) / 2 + 20;
  for (int i = 0; i < indexBottom; i++) {
    arduboy.setCursor(xBot + i * 6, 34);
    arduboy.print(titleBottom[i]);
  }
   // Подпись для продолжения
  arduboy.setCursor(75, 55);
  arduboy.print(F("A - NEXT"));

  // Мигающая неоновая рамка
  if ((millis() / 400) % 2 == 0) {
    arduboy.drawRoundRect(0, 0, 128, 64, 8, WHITE);
  }
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_TUTORIAL_1; // Переходим к обучению вместо меню
  }
}

// ------------------------------------------------------
// Функции для слайдов обучения
// ------------------------------------------------------
void updateTutorial1() {
  arduboy.drawSlowXYBitmap(-60, -5, salamander_mini, 89, 41, WHITE);
  arduboy.drawSlowXYBitmap(-5, -5, honey_badger_mini, 70, 35, WHITE);
  arduboy.drawSlowXYBitmap(70, -5, alpaca_face_mini, 54, 42, WHITE);
  arduboy.drawSlowXYBitmap(40, -5, capybara_mini, 61, 43, WHITE);

  arduboy.setCursor(3, 35);
  arduboy.print(F("We are Tribes"));
  arduboy.setCursor(3, 45);
  arduboy.print(F("Welcome You on campus"));
  arduboy.setCursor(75, 55);
  arduboy.print(F("A - NEXT"));

  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_TUTORIAL_2;
  }
}

void updateTutorial2() {
  arduboy.clear();
  
  // Заголовок
  arduboy.setCursor(15, 2);
  arduboy.print(F("HOW TO PLAY"));
  
  // Основной текст
  arduboy.setCursor(3, 15);
  arduboy.print(F("buttons:"));
  arduboy.setCursor(5, 25);
  arduboy.print(F("UP/DOWN - for move"));
  
  arduboy.setCursor(3, 35);
  arduboy.print(F("LEFT/RIGHT - turn"));
  arduboy.setCursor(5, 45);
  arduboy.print(F("UP+A - push boxes"));
  
  // Подпись для продолжения
  arduboy.setCursor(75, 55);
  arduboy.print(F("A - NEXT"));
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_TUTORIAL_3;
  }
}

void updateTutorial3() {
  static int scrollPosition = 128; // Начинаем за правым краем экрана
  static unsigned long lastScrollTime = 0;
  const char* runningText = "Solve the puzzle and help the tribes find their way back to School 21.";
  
  arduboy.clear();
  
  // Заголовок
  arduboy.setCursor(15, 2);
  arduboy.print(F("GOAL OF GAME"));
  
  // Основной текст
  arduboy.setCursor(15, 15);
  arduboy.print(F("Push the boxes"));
  arduboy.setCursor(15, 25);
  arduboy.print(F("into the target"));
  
  // Обновляем позицию каждые 50ms для плавного движения
  if (millis() - lastScrollTime > 50) {
    scrollPosition--;
    lastScrollTime = millis();
    
    // Если текст полностью ушел за левый край, начинаем сначала
    int textWidth = strlen(runningText) * 6; // Приблизительная ширина текста
    if (scrollPosition < -textWidth) {
      scrollPosition = 128;
    }
  }
  
  // Рисуем бегущую строку
  arduboy.setCursor(scrollPosition, 45);
  arduboy.print(runningText);
  
  // Подпись для продолжения
  arduboy.setCursor(75, 55);
  arduboy.print(F("A - NEXT"));
  
  // Простая графика - ящик и цель
  arduboy.fillRect(108, 10, 10, 10, WHITE); // Ящик
  arduboy.drawRect(110, 12, 6, 6, BLACK);   // Внутренняя рамка
  
  arduboy.drawLine(108, 25, 118, 35, WHITE); // Крестик цели
  arduboy.drawLine(118, 25, 108, 35, WHITE);
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_TUTORIAL_4;
    // Сбрасываем позицию для следующего показа
    scrollPosition = 128;
  }
}

void updateTutorial4() {
  arduboy.clear();
  
  // Заголовок
  arduboy.setCursor(10, 2);
  arduboy.print(F("DIFFICULTY LEVELS"));
  
  // Основной текст
  arduboy.setCursor(2, 15);
  arduboy.print(F("Bottom A - in/out 2D"));
  arduboy.setCursor(2, 25);
  arduboy.print(F("HARD unuse 2D map"));
  
  arduboy.setCursor(2, 35);
  arduboy.print(F("MEDIUM can view 2D"));
  arduboy.setCursor(2, 45);
  arduboy.print(F("EASY can push in 2D"));
  
   
  // Подпись для начала игры
  arduboy.setCursor(75, 55);
  arduboy.print(F("A - NEXT"));
  
  if (arduboy.justPressed(A_BUTTON)) {
    gameState = STATE_MENU;
  }
}

// ------------------------------------------------------
// setup / loop
// ------------------------------------------------------
void setup() {
  arduboy.begin();
  arduboy.clear();
  arduboy.setFrameRate(60);

  arduboy.audio.begin();
  arduboy.audio.on();

  gameState = STATE_SHOW_LOGO;
  menuMusicPlaying = false;
  gameDifficulty = DIFF_EASY;
  
  // Инициализируем время движения при старте
  lastMoveTime = 0;
  lastMapMoveTime = 0;
}

void loop() {
  if (!arduboy.nextFrame()) return;

  arduboy.pollButtons();
  arduboy.clear();

  switch (gameState) {
    case STATE_SHOW_LOGO:
      updateLogoShow();
      break;
        case STATE_TUTORIAL_1:
      updateTutorial1();
      break;
    case STATE_TUTORIAL_2:
      updateTutorial2();
      break;
    case STATE_TUTORIAL_3:
      updateTutorial3();
      break;
    case STATE_TUTORIAL_4:
      updateTutorial4();
      break;
    case STATE_MENU:
      updateMenu();
      break;
    case STATE_PLAYING:
    case STATE_MAP_VIEW:
      updateGame();
      break;
    // case STATE_BOX_CONFIRM:
    //   updateBoxConfirm();
    //   break;
    case STATE_LEVEL_COMPLETE:
      updateLevelComplete();
      break;
    case STATE_SHOW_TRIBE:
      updateShowTribe();
      break;
    case STATE_GAME_COMPLETE:
      updateGameComplete();
      break;
    case STATE_EXIT:
      updateExitScreen();
      break;
  }

  arduboy.display();
}